// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package autogen

import (
	"context"
	"fmt"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func DatabaseUserResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"auth_database_name": schema.StringAttribute{
				Required:            true,
				Description:         "Database against which the database user authenticates. Database users must provide both a username and authentication database to log into MongoDB.",
				MarkdownDescription: "Database against which the database user authenticates. Database users must provide both a username and authentication database to log into MongoDB.",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"admin",
						"$external",
					),
				},
			},
			"aws_iam_type": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Human-readable label that indicates whether the new database user authenticates with the Amazon Web Services (AWS) Identity and Access Management (IAM) credentials associated with the user or the user's role.",
				MarkdownDescription: "Human-readable label that indicates whether the new database user authenticates with the Amazon Web Services (AWS) Identity and Access Management (IAM) credentials associated with the user or the user's role.",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"NONE",
						"USER",
						"ROLE",
					),
				},
				Default: stringdefault.StaticString("NONE"),
			},
			"id": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"ldap_auth_type": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Part of the Lightweight Directory Access Protocol (LDAP) record that the database uses to authenticate this database user on the LDAP host.",
				MarkdownDescription: "Part of the Lightweight Directory Access Protocol (LDAP) record that the database uses to authenticate this database user on the LDAP host.",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"NONE",
						"GROUP",
						"USER",
					),
				},
				Default: stringdefault.StaticString("NONE"),
			},
			"oidc_auth_type": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Human-readable label that indicates whether the new database user authenticates with OIDC federated authentication. To create a federated authentication user, specify the value of IDP_GROUP for this field.",
				MarkdownDescription: "Human-readable label that indicates whether the new database user authenticates with OIDC federated authentication. To create a federated authentication user, specify the value of IDP_GROUP for this field.",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"NONE",
						"IDP_GROUP",
					),
				},
				Default: stringdefault.StaticString("NONE"),
			},
			"password": schema.StringAttribute{
				Optional:            true,
				Sensitive:           true,
				Description:         "Alphanumeric string that authenticates this database user against the database specified in `databaseName`. To authenticate with SCRAM-SHA, you must specify this parameter. This parameter doesn't appear in this response.",
				MarkdownDescription: "Alphanumeric string that authenticates this database user against the database specified in `databaseName`. To authenticate with SCRAM-SHA, you must specify this parameter. This parameter doesn't appear in this response.",
				Validators: []validator.String{
					stringvalidator.LengthAtLeast(8),
					stringvalidator.ConflictsWith(path.Expressions{path.MatchRelative().AtParent().AtName("x509_type"), path.MatchRelative().AtParent().AtName("ldap_auth_type"), path.MatchRelative().AtParent().AtName("aws_iam_type")}...),
				},
			},
			"project_id": schema.StringAttribute{
				Required:            true,
				Description:         "Unique 24-hexadecimal digit string that identifies the project.",
				MarkdownDescription: "Unique 24-hexadecimal digit string that identifies the project.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					stringvalidator.LengthBetween(24, 24),
					stringvalidator.RegexMatches(regexp.MustCompile("^([a-f0-9]{24})$"), ""),
				},
			},
			"username": schema.StringAttribute{
				Required:            true,
				Description:         "Human-readable label that represents the user that authenticates to MongoDB. The format of this label depends on the method of authentication:\n\n| Authentication Method | Parameter Needed | Parameter Value | username Format |\n|---|---|---|---|\n| AWS IAM | awsType | ROLE | <abbr title=\"Amazon Resource Name\">ARN</abbr> |\n| AWS IAM | awsType | USER | <abbr title=\"Amazon Resource Name\">ARN</abbr> |\n| x.509 | x509Type | CUSTOMER | [RFC 2253](https://tools.ietf.org/html/2253) Distinguished Name |\n| x.509 | x509Type | MANAGED | [RFC 2253](https://tools.ietf.org/html/2253) Distinguished Name |\n| LDAP | ldapAuthType | USER | [RFC 2253](https://tools.ietf.org/html/2253) Distinguished Name |\n| LDAP | ldapAuthType | GROUP | [RFC 2253](https://tools.ietf.org/html/2253) Distinguished Name |\n| OIDC | oidcAuthType | IDP_GROUP | Atlas OIDC IdP ID (found in federation settings), followed by a '/', followed by the IdP group name |\n| SCRAM-SHA | awsType, x509Type, ldapAuthType, oidcAuthType | NONE | Alphanumeric string |\n",
				MarkdownDescription: "Human-readable label that represents the user that authenticates to MongoDB. The format of this label depends on the method of authentication:\n\n| Authentication Method | Parameter Needed | Parameter Value | username Format |\n|---|---|---|---|\n| AWS IAM | awsType | ROLE | <abbr title=\"Amazon Resource Name\">ARN</abbr> |\n| AWS IAM | awsType | USER | <abbr title=\"Amazon Resource Name\">ARN</abbr> |\n| x.509 | x509Type | CUSTOMER | [RFC 2253](https://tools.ietf.org/html/2253) Distinguished Name |\n| x.509 | x509Type | MANAGED | [RFC 2253](https://tools.ietf.org/html/2253) Distinguished Name |\n| LDAP | ldapAuthType | USER | [RFC 2253](https://tools.ietf.org/html/2253) Distinguished Name |\n| LDAP | ldapAuthType | GROUP | [RFC 2253](https://tools.ietf.org/html/2253) Distinguished Name |\n| OIDC | oidcAuthType | IDP_GROUP | Atlas OIDC IdP ID (found in federation settings), followed by a '/', followed by the IdP group name |\n| SCRAM-SHA | awsType, x509Type, ldapAuthType, oidcAuthType | NONE | Alphanumeric string |\n",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					stringvalidator.LengthAtMost(1024),
				},
			},
			"x509_type": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "X.509 method that MongoDB Cloud uses to authenticate the database user.\n\n- For application-managed X.509, specify `MANAGED`.\n- For self-managed X.509, specify `CUSTOMER`.\n\nUsers created with the `CUSTOMER` method require a Common Name (CN) in the **username** parameter. You must create externally authenticated users on the `$external` database.",
				MarkdownDescription: "X.509 method that MongoDB Cloud uses to authenticate the database user.\n\n- For application-managed X.509, specify `MANAGED`.\n- For self-managed X.509, specify `CUSTOMER`.\n\nUsers created with the `CUSTOMER` method require a Common Name (CN) in the **username** parameter. You must create externally authenticated users on the `$external` database.",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"NONE",
						"CUSTOMER",
						"MANAGED",
					),
				},
				Default: stringdefault.StaticString("NONE"),
			},
		},
		Blocks: map[string]schema.Block{
			"labels": schema.SetNestedBlock{
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"key": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Key applied to tag and categorize this component.",
							MarkdownDescription: "Key applied to tag and categorize this component.",
							Validators: []validator.String{
								stringvalidator.LengthBetween(1, 255),
							},
						},
						"value": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Value set to the Key applied to tag and categorize this component.",
							MarkdownDescription: "Value set to the Key applied to tag and categorize this component.",
							Validators: []validator.String{
								stringvalidator.LengthBetween(1, 255),
							},
						},
					},
					CustomType: LabelsType{
						ObjectType: types.ObjectType{
							AttrTypes: LabelsValue{}.AttributeTypes(ctx),
						},
					},
				},
			},
			"roles": schema.SetNestedBlock{
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"collection_name": schema.StringAttribute{
							Optional:            true,
							Description:         "Collection on which this role applies.",
							MarkdownDescription: "Collection on which this role applies.",
						},
						"database_name": schema.StringAttribute{
							Required:            true,
							Description:         "Database against which the database user authenticates. Database users must provide both a username and authentication database to log into MongoDB.",
							MarkdownDescription: "Database against which the database user authenticates. Database users must provide both a username and authentication database to log into MongoDB.",
						},
						"role_name": schema.StringAttribute{
							Required:            true,
							Description:         "Human-readable label that identifies a group of privileges assigned to a database user. This value can either be a built-in role or a custom role.",
							MarkdownDescription: "Human-readable label that identifies a group of privileges assigned to a database user. This value can either be a built-in role or a custom role.",
						},
					},
					CustomType: RolesType{
						ObjectType: types.ObjectType{
							AttrTypes: RolesValue{}.AttributeTypes(ctx),
						},
					},
				},
			},
			"scopes": schema.SetNestedBlock{
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"name": schema.StringAttribute{
							Optional:            true,
							Description:         "Human-readable label that identifies the cluster or MongoDB Atlas Data Lake that this database user can access.",
							MarkdownDescription: "Human-readable label that identifies the cluster or MongoDB Atlas Data Lake that this database user can access.",
							Validators: []validator.String{
								stringvalidator.LengthBetween(1, 64),
								stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Z0-9][a-zA-Z0-9-]*$"), ""),
							},
						},
						"typee": schema.StringAttribute{
							Optional:            true,
							Description:         "Category of resource that this database user can access.",
							MarkdownDescription: "Category of resource that this database user can access.",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"CLUSTER",
									"DATA_LAKE",
								),
							},
						},
					},
					CustomType: ScopesType{
						ObjectType: types.ObjectType{
							AttrTypes: ScopesValue{}.AttributeTypes(ctx),
						},
					},
				},
			},
		},
	}
}

type DatabaseUserModel struct {
	AuthDatabaseName types.String `tfsdk:"auth_database_name"`
	AwsIamType       types.String `tfsdk:"aws_iam_type"`
	Id               types.String `tfsdk:"id"`
	LdapAuthType     types.String `tfsdk:"ldap_auth_type"`
	OidcAuthType     types.String `tfsdk:"oidc_auth_type"`
	Password         types.String `tfsdk:"password"`
	ProjectId        types.String `tfsdk:"project_id"`
	Username         types.String `tfsdk:"username"`
	X509Type         types.String `tfsdk:"x509_type"`
	Labels           types.Set    `tfsdk:"labels"`
	Roles            types.Set    `tfsdk:"roles"`
	Scopes           types.Set    `tfsdk:"scopes"`
}

var _ basetypes.ObjectTypable = LabelsType{}

type LabelsType struct {
	basetypes.ObjectType
}

func (t LabelsType) Equal(o attr.Type) bool {
	other, ok := o.(LabelsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LabelsType) String() string {
	return "LabelsType"
}

func (t LabelsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LabelsValue{
		Key:   keyVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewLabelsValueNull() LabelsValue {
	return LabelsValue{
		state: attr.ValueStateNull,
	}
}

func NewLabelsValueUnknown() LabelsValue {
	return LabelsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLabelsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LabelsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LabelsValue Attribute Value",
				"While creating a LabelsValue value, a missing attribute value was detected. "+
					"A LabelsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LabelsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LabelsValue Attribute Type",
				"While creating a LabelsValue value, an invalid attribute value was detected. "+
					"A LabelsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LabelsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LabelsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LabelsValue Attribute Value",
				"While creating a LabelsValue value, an extra attribute value was detected. "+
					"A LabelsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LabelsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLabelsValueUnknown(), diags
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewLabelsValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewLabelsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewLabelsValueUnknown(), diags
	}

	return LabelsValue{
		Key:   keyVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewLabelsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LabelsValue {
	object, diags := NewLabelsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLabelsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LabelsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLabelsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLabelsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLabelsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLabelsValueMust(t.AttrTypes, attributes), nil
}

func (t LabelsType) ValueType(ctx context.Context) attr.Value {
	return LabelsValue{}
}

var _ basetypes.ObjectValuable = LabelsValue{}

type LabelsValue struct {
	Key   basetypes.StringValue `tfsdk:"key"`
	Value basetypes.StringValue `tfsdk:"value"`
	state attr.ValueState
}

func (v LabelsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LabelsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LabelsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LabelsValue) String() string {
	return "LabelsValue"
}

func (v LabelsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"key":   basetypes.StringType{},
			"value": basetypes.StringType{},
		},
		map[string]attr.Value{
			"key":   v.Key,
			"value": v.Value,
		})

	return objVal, diags
}

func (v LabelsValue) Equal(o attr.Value) bool {
	other, ok := o.(LabelsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v LabelsValue) Type(ctx context.Context) attr.Type {
	return LabelsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LabelsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"key":   basetypes.StringType{},
		"value": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RolesType{}

type RolesType struct {
	basetypes.ObjectType
}

func (t RolesType) Equal(o attr.Type) bool {
	other, ok := o.(RolesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RolesType) String() string {
	return "RolesType"
}

func (t RolesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	collectionNameAttribute, ok := attributes["collection_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection_name is missing from object`)

		return nil, diags
	}

	collectionNameVal, ok := collectionNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection_name expected to be basetypes.StringValue, was: %T`, collectionNameAttribute))
	}

	databaseNameAttribute, ok := attributes["database_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`database_name is missing from object`)

		return nil, diags
	}

	databaseNameVal, ok := databaseNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`database_name expected to be basetypes.StringValue, was: %T`, databaseNameAttribute))
	}

	roleNameAttribute, ok := attributes["role_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role_name is missing from object`)

		return nil, diags
	}

	roleNameVal, ok := roleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role_name expected to be basetypes.StringValue, was: %T`, roleNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RolesValue{
		CollectionName: collectionNameVal,
		DatabaseName:   databaseNameVal,
		RoleName:       roleNameVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewRolesValueNull() RolesValue {
	return RolesValue{
		state: attr.ValueStateNull,
	}
}

func NewRolesValueUnknown() RolesValue {
	return RolesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRolesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RolesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RolesValue Attribute Value",
				"While creating a RolesValue value, a missing attribute value was detected. "+
					"A RolesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RolesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RolesValue Attribute Type",
				"While creating a RolesValue value, an invalid attribute value was detected. "+
					"A RolesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RolesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RolesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RolesValue Attribute Value",
				"While creating a RolesValue value, an extra attribute value was detected. "+
					"A RolesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RolesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRolesValueUnknown(), diags
	}

	collectionNameAttribute, ok := attributes["collection_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`collection_name is missing from object`)

		return NewRolesValueUnknown(), diags
	}

	collectionNameVal, ok := collectionNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`collection_name expected to be basetypes.StringValue, was: %T`, collectionNameAttribute))
	}

	databaseNameAttribute, ok := attributes["database_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`database_name is missing from object`)

		return NewRolesValueUnknown(), diags
	}

	databaseNameVal, ok := databaseNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`database_name expected to be basetypes.StringValue, was: %T`, databaseNameAttribute))
	}

	roleNameAttribute, ok := attributes["role_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role_name is missing from object`)

		return NewRolesValueUnknown(), diags
	}

	roleNameVal, ok := roleNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role_name expected to be basetypes.StringValue, was: %T`, roleNameAttribute))
	}

	if diags.HasError() {
		return NewRolesValueUnknown(), diags
	}

	return RolesValue{
		CollectionName: collectionNameVal,
		DatabaseName:   databaseNameVal,
		RoleName:       roleNameVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewRolesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RolesValue {
	object, diags := NewRolesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRolesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RolesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRolesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRolesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRolesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRolesValueMust(t.AttrTypes, attributes), nil
}

func (t RolesType) ValueType(ctx context.Context) attr.Value {
	return RolesValue{}
}

var _ basetypes.ObjectValuable = RolesValue{}

type RolesValue struct {
	CollectionName basetypes.StringValue `tfsdk:"collection_name"`
	DatabaseName   basetypes.StringValue `tfsdk:"database_name"`
	RoleName       basetypes.StringValue `tfsdk:"role_name"`
	state          attr.ValueState
}

func (v RolesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["collection_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["database_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["role_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.CollectionName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["collection_name"] = val

		val, err = v.DatabaseName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["database_name"] = val

		val, err = v.RoleName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["role_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RolesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RolesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RolesValue) String() string {
	return "RolesValue"
}

func (v RolesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"collection_name": basetypes.StringType{},
			"database_name":   basetypes.StringType{},
			"role_name":       basetypes.StringType{},
		},
		map[string]attr.Value{
			"collection_name": v.CollectionName,
			"database_name":   v.DatabaseName,
			"role_name":       v.RoleName,
		})

	return objVal, diags
}

func (v RolesValue) Equal(o attr.Value) bool {
	other, ok := o.(RolesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CollectionName.Equal(other.CollectionName) {
		return false
	}

	if !v.DatabaseName.Equal(other.DatabaseName) {
		return false
	}

	if !v.RoleName.Equal(other.RoleName) {
		return false
	}

	return true
}

func (v RolesValue) Type(ctx context.Context) attr.Type {
	return RolesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RolesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"collection_name": basetypes.StringType{},
		"database_name":   basetypes.StringType{},
		"role_name":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ScopesType{}

type ScopesType struct {
	basetypes.ObjectType
}

func (t ScopesType) Equal(o attr.Type) bool {
	other, ok := o.(ScopesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ScopesType) String() string {
	return "ScopesType"
}

func (t ScopesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	typeeAttribute, ok := attributes["typee"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`typee is missing from object`)

		return nil, diags
	}

	typeeVal, ok := typeeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`typee expected to be basetypes.StringValue, was: %T`, typeeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ScopesValue{
		Name:  nameVal,
		Typee: typeeVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewScopesValueNull() ScopesValue {
	return ScopesValue{
		state: attr.ValueStateNull,
	}
}

func NewScopesValueUnknown() ScopesValue {
	return ScopesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewScopesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ScopesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ScopesValue Attribute Value",
				"While creating a ScopesValue value, a missing attribute value was detected. "+
					"A ScopesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ScopesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ScopesValue Attribute Type",
				"While creating a ScopesValue value, an invalid attribute value was detected. "+
					"A ScopesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ScopesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ScopesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ScopesValue Attribute Value",
				"While creating a ScopesValue value, an extra attribute value was detected. "+
					"A ScopesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ScopesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewScopesValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewScopesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	typeeAttribute, ok := attributes["typee"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`typee is missing from object`)

		return NewScopesValueUnknown(), diags
	}

	typeeVal, ok := typeeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`typee expected to be basetypes.StringValue, was: %T`, typeeAttribute))
	}

	if diags.HasError() {
		return NewScopesValueUnknown(), diags
	}

	return ScopesValue{
		Name:  nameVal,
		Typee: typeeVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewScopesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ScopesValue {
	object, diags := NewScopesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewScopesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ScopesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewScopesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewScopesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewScopesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewScopesValueMust(t.AttrTypes, attributes), nil
}

func (t ScopesType) ValueType(ctx context.Context) attr.Value {
	return ScopesValue{}
}

var _ basetypes.ObjectValuable = ScopesValue{}

type ScopesValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	Typee basetypes.StringValue `tfsdk:"typee"`
	state attr.ValueState
}

func (v ScopesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["typee"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Typee.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["typee"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ScopesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ScopesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ScopesValue) String() string {
	return "ScopesValue"
}

func (v ScopesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"name":  basetypes.StringType{},
			"typee": basetypes.StringType{},
		},
		map[string]attr.Value{
			"name":  v.Name,
			"typee": v.Typee,
		})

	return objVal, diags
}

func (v ScopesValue) Equal(o attr.Value) bool {
	other, ok := o.(ScopesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Typee.Equal(other.Typee) {
		return false
	}

	return true
}

func (v ScopesValue) Type(ctx context.Context) attr.Type {
	return ScopesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ScopesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name":  basetypes.StringType{},
		"typee": basetypes.StringType{},
	}
}
